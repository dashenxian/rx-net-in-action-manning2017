# 前言

.NET 的反应式扩展（Reactive Extensions，Rx）首发于 2009 年 11 月，当时是如此介绍的：「Rx 允许开发者编写精炼的声明式代码（declarative code），通过 .NET 常用的方式方法编排（orchestrate）和协调（coordinate）异步的和基于事件的程序」。（参考 [http://mng.bz/gQ31](http://mng.bz/gQ31)）

我还记得我初次接触 Rx 的例子和讨论的样子。我吃惊于这些解决方案的优雅与精炼。然而当我尝试使用 Rx 时，我却发现反应式编程（reactive programming）并不简单，我必须转变自己的思维方式。在那段岁月中，有关 Rx 主题的资料并不多，我必须通过不断解决遇到的问题并反复实践来学习 Rx。

2012 年我退役并加入 [CodeValue](www.codevalue.net)，当时我有两个主要项目让我真正领会到了 Rx 的精髓。第一个项目是一个有关网络安全（cybersecurity）的程序，要求对多个事件（multiple events）做出反应并协调它们的工作，以便为终端用户（the end user）显示这些并行运行的各事件的状态。第二个项目是有关视频聊天（video chat）的，它需要在移动端和 PC 端设备上运行。视频聊天程序需要对诸如用户登录登出、接受各类须以不同方式加以处理的消息等做出响应。尽管这是两个不同的系统，但它们都需要基于事件地写流（writing a flow based on events），这其中涉及到在流中对接收值过滤（filtering of received values）、对异步（asynchronicity）和并发（concurrency）的处理以及对重复事件的识别模式等，以便应用程序可以有效并正确地响应（respond efficiently and correctly）。我为这两个项目引入了 Rx，并为此大获成功——无论是效果还是开发进度上都超出了我们的预料。

尽管我对 Rx 已经有所了解，但在使用时仍频繁踩坑，而且关于 Rx 的资料真的太少了，不管是书还是文章。很多次掉坑里的原因是我的同事们缺乏对新事物的了解。幸运的是，在我找出问题根源后，问题往往很容易修复，这也是拜 Rx 的灵活性所赐。在随后的的几年中，我开始通过博客介绍 Rx 以及如何轻松解决复杂问题。这也是本书写作的动力。我打算创建一个循序渐进的指南（step-by-step guide），其中包含有 .NET 工程师们所需要学习的部分，以便最大限度地利用 Rx 库和反应式编程范例（the reactive programming paradigm）。同时我还会记录一些我多年来的实践经验，包括所遇到的陷阱以及相应的解决方案。

为了确保能让本书达到我的目的，我需要十分细心。为了能突显重点，我不得不重写一些章节、改变一些主题，并筛除了一部分素材，最后诞生了你此刻手上的这本书——Rx.NET in Action。这本书可以从前向后一章章阅读，也可以直接阅读特定章节来解决问题或加深记忆。

Rx 还在不断发展，它被移植到了许多其它语言和平台中。Rx 是 [.NET 基金会（.NET Foundation）](www.dotnetfoundation.org) 的开源项目。我希望 Rx 能成为一种 .NET 编写、编排、协调异步和基于事件的程序的事实标准（de facto way），本书将为你提供打开 Rx 新世界大门所需的一切。
